### 오픈소스 SW개론 첫번째 과제

#### 쉘스크립트 관련 getopt / getopts 

#### 리눅스 명령어 관련 sed / awk


##### getopt란

```c
#include <unistd.h >

int getopt(int argc, char *const argv[], const char *option);
```

getopt 함수는 옵션을 분석할수있게 제공하는 시스템 호출이다.

getopt 함수에 첫인자와 두번째인자는 main 함수의 argc와 arg를 그대로 전달하고, 세번째 옵셔에 제공하고자한느 옵션을 전달한다.

가령 a, l 옵션을 전달하고자 한다면, al 이라고 전달하게 된다. 그리고 옵션뒤에 인자를 사용해야 한다면 : 을 추가하게 된다.

만약 a에는 옵션뒤에 인자를 사용하고, l 에는 옵션뒤에 인자를 사용하지 않는다면, a:l 을 전달하게 된다



getopt 함수는 이번에 발견한 옵션의 아스키코드값을 반환하게 되며, 옵션 뒤에 인자를 사용하고자 한다면 이미 선언한 optarg를 이용한다.

그리고 더 이상 옵션을 발견하지 못하게될 경우 EOF를 반환하게 된다.


-------------------------


##### getopts란


```
getopts OptionString Name[
  Arguments ....
]
```

getopts 명령은 매개변수 리스트에서 옵션 및 옵션인수를 검색하는 Korn/POSIX 쉘 내장 명령이다. 옵션은 + 혹은 - 부호로 시작하고 그 뒤에 문자가 오게된다.

'+' 혹은 '-' 로 시작하지 않는 옵션은 OptionString 을 종료한다. getopts명령은 호출될 떄마다 다음옵션값과 쉔 변수 OPTIND에서 처리될 다음인수의 색인을 배치한다.

쉘이 호출될떄마다 OPTIND는 1로 초기화됩니다. 옵션인 +로 시작된 경우 +는 Name의 값 앞에 추가된다.


OptionString의 문자 뒤에는 콜란이 오면 옵션에 인수가 있는것으로 간주된다. 옵션에 옵션-인수가 필요한 경우 getopts명령은 이를 변수 OPTARG에 배치하게 된다.

OptionString에 포함되지 않은 옵션문자가 발견되거나 찾은 옵션에 필요한 옵션 - 인수가 없는경우  :  
  * Name은 ? 문자로 설정된다
  * OPTARG가 설정되지 않으며
  * 진단 메시지가 표준오류에 기록된다.

이 조건은 getopts명령을 처리하는 중에 생긴 오류가 아니라 호출 어플리케이션에 인수가 표시되는 중에 발견된 오류라고 간주된다.

진단 메시지는 명시된내용과 같이 기록되지만 종료 상태는 0이 된다.

OptionString이 콜론으로 시작되는 경우
  * Name은 ? 문자로 설정되거나 누락된 필수옵션에 대해서는 콜론 문자로 설정된다.
  * OPTARG는 발견된 옵션문자로 설정되고
  * 출력이 표준오류에 기록되지 않는다.


  
다음 중 하나가 옵션의 끝을 식별하게 된다. 특수옵션 --, 이 - 또는 + 로 시작되지 않는 인수를 찾는경우 또는 오류가 발생하는경우.
옵션의 끝에 도달하는 경우 :
  * getopts 명령은 0보다 큰 리턴값으로 종료된다
  * OPTARG는 첫번째 비옵션-인수의 색인으로 설정된다. 여기서, 첫 번쨰 --인수는 그 전에 다른 비옵션-인수가 나타나지 않는 경우 옵션-인수로 간주되고 비옵션-인수가 없는 경우에는 값 $#+1로 간주된다.
  * Name은 ? 문자로 설정됩니다.

--------------------------------------

##### sed란

sed는 스트림 편집기이다.

ed 명령어와 grep 명령어 기능의 일부를 합친것이 sed(stream editor) 명령어이다.

sed명령어 역시 grep명령어와 같은 필터이지만 이 명령어는 파일을 수정할수 있게해주는 대신 ed처럼 대화식처리는 불가능하다. sed 명령어는 1개 라인씩 입력 라인을 읽어들여 표준출력으로 출력한다.


sed는 각 라인을 읽을때 마다 ed에서 사용하던 형식의 대치작업을 실행한다. 일치하는 문자열이 있으면 그 문자열을 대치한 후 출력하고 일치하는 문자열이 없으면 그 라인은 수정되지 않고 그대로 출력된다.


이 sed 명령어가 ed보다 좋은 점은 라인들을 하나씩 읽고, 수정하고, 출력하기 때문에 기억장치 안의 버퍼를 사용하지 않는다는 것이다. 버퍼를 사용하지 않으면 파일의 크기에 제한없이 작없이 작업을 할 수 있다. 

ed와 같이 버퍼를 사용하는 경우는 버퍼의 크기보다 큰 파일은 처리할수 없으며 대부분 버퍼의 크기는 1MB정도이다. 따라서 sed 는 아주 큰 파일을 처리할때 주로 사용된다.

sed 명령어를 호출하는 형식은 grep 명령어와 같지만 완전한 형식의 대치 연산자를 사용한다는 점에서 차이가 있다.

> sed 명령어의 사용법

  * 치환
  ```
  sed 's/appel/apple/' test.txt : appel를 apple로 바꾼다. 단, 원본파일을 바꾸지 않고 표준출력만 한다.
  sed 's/\t/\ /' test.txt : 탭문자를 엔터로 변환

  ```
  * 삭제
  ```
  sed '/AA/d' a.html : AA 문자가 포함된 줄을 삭제하여 출력한다.
  sed '/BB/!d' a.html : BB 문자가 있는 줄만 지우지 않는다.
  sed '1,2d' a.html : 처음 1줄, 2줄을 지운다.
  sed '/^$/d a.html : 공백라인을 삭제하는 명령이다.
  ```
  
